<center><font face="黑体" size="8">操作系统</font><br/></center>
## 进程和线程的定义及区别

**进程** ：是具有一定独立功能的程序关于某个数据集合上的一次运行活动，**进程**是系统**进行资源分配和调度**的一个独立单位。

**线程** ：是进程的一个实体，是**cpu调度和分配的基本单位**，它是比进程更小的能独立运行的基本单位。

## 程序与进程的区别

* 进程是一个**动态**概念，而程序是一个**静态**概念。
* 进程具有**并行特征**（并发性），而程序不反映执行所以没有并性特征。
* 进程是竞争计算机系统资源的基本单位，而程序不反映执行也就不会竞争计算机系统资源。
* 进程具有生命周期。
* 一个程序可以对应多个进程，一个进程可以执行一个或多个程序。

## 中断的的分类：4个

1. **程序中断**：在某些条件下，由指令执行的结果产生，例如算术溢出、除数为0、试图执行一条非法的机器指令以及访问用户不允许的存储位置。
2. **时钟中断**：由处理器内部的计时器产生，允许操作系统以一定规律执行函数。
3. **I/O中断**：由I/O控制器产生，用于发信号通知一个操作的正常完成或各种错误条件。
4. **硬件失效中断**：由诸如掉电或存储器奇偶校验错之类的故障发生。

## 死锁

* **死锁的含义**：在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲就是**两个或多个进程无限期的阻塞、相互等待**的一种状态。

* **产生死锁的四个条件**：

  1、**互斥**。一次只有一个进程可以使用一个资源。

  2、**占有且等待**。当一个进程等待其它进程时，继续占有已经分配的资源。

  3、**不可抢占**。不能强行抢占进程以占有的资源。

  4、**循环等待**。系统中若干进程组成环路，该环路中每个进程都在等待相邻进程正占用的资源。

* **死锁预防**：一种是间接的死锁预防方法，即防止前列出的三个必要条件中的任何一个的发生；一种是直接的死锁预防方法，即防止循环等待的发生。

## 内存池、线程池、进程池

**内存池**：内存池是指程序预先从操作系统申请的一块足够大内存，此后，当程序中需要申请内存的时候，不是直接向操作系统申请，而是直接从内存池中获取；同理，当程序释放内存的时候，并不真正将内存返回给操作系统，而是返回内存池。当程序退出（或者特定时间）时，内存池才将之前申请的内存真正释放。

**进程池/线程池**：在面向对象程序编程中，对象的创建与析构都是一个较为复杂的过程，较费时间，所以为了提高程序的运行效率尽可能减少创建和销毁对象的次数，特别是一些很耗资源的对象创建和销毁。所以我们可以创建一个进程池（线程池），预先放一些进程（线程）进去，要用的时候就直接调用，用完之后再把进程归还给进程池，省下创建删除进程的时间，不过当然就需要额外的开销了。
线程池的流程如下：先启动若干数量的线程，并让这些线程都处于睡眠状态，当需要一个开辟一个线程去做具体的工作时，就会唤醒线程池中的某一个睡眠线程，让它去做具体工作，当工作完成后，线程又处于睡眠状态，而不是将线程销毁。

## 页面置换算法

1. **最佳置换算法（Optimal）**：即选择那些永不使用的，或者是在最长时间内不再被访问的页面置换出去。

2. **先进先出置换算法（FIFO）**：该算法总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面予以淘汰。

3. **最近最久未使用置换算法LRU**（least recently used）：该算法是选择最近最久未使用的页面予以淘汰，系统在每个页面设置一个访问字段，用以记录这个页面自上次被访问以来所经历的时间T，当要淘汰一个页面时，选择T最大的页面

4. **Clock置换算法**：也叫最近未用算法NRU（Not Recently Used）。该算法为每个页面设置一位访问位，将内存中的所有页面都通过链接指针链成一个循环队列。当某页被访问时，其访问位置置为“1”。在选择一页淘汰时，就检查其访问位，如果是“0”，就选择该页换出；若为“1”，则重新置为“0”，暂不换出该页，在循环队列中检查下一个页面，直到访问位为“0”的页面为止。

5. **最少使用置换算法LFU**：该算法选择最近时期使用最少的页面作为淘汰页。

## 磁盘调度算法

1. **先来先服务算法（FCFS）**：FCFS算法根据**进程请求访问磁盘的先后顺序**进行调度，，这是一种最简单的调度算法。该算法的优点是具有公平性。
2. **最短寻道时间优先算法（SSTF）**：SSTF算法选择调度处理的磁道是**与当前磁头所在磁道距离最近**的磁道，以使每次的寻找时间最短。
3. **扫描(SCAN)（电梯）算法**：SCAN算法**在磁头当前移动方向上选择与当前磁头所在磁道距离最近的请求**作为下一次服务的对象。SCAN算法对最近扫描过的区域不公平，因此，它在**局部性**方面不如FCFS算法和SSTF算法好。
4. **循环扫描(CSCAN)算法**：在扫描算法的基础上**规定磁头单向移动来提供服务**，回返时直接快速移动至起始端而不服务任何请求。

## 进程调度算法

1. **先来先服务FCFS**：FCFS调度算法是一种最简单的调度算法，该调度算法既可以用于作业调度也可以用于进程调度。在作业调度中，算法每次从后备作业队列中选择最先进入该队列的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。

2. **最短进程优先SPN**：短作业（进程）优先调度算法是指对短作业（进程）优先调度的算法。短作业优先调度（SJF）算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存中运行。而短进程优先（SPF）调度算法，则是从就绪队列中选择一个估计运行时间最短的进程，将处理机分配给它，使之立即执行，直到完成或发生某事件而阻塞时，才释放处理机。

3. **最高响应比优先**：高响应比优先调度算法主要用于作业调度，该算法是对FCFS调度算法和SJF调度算法的一种综合平衡，同时考虑每个作业的等待时间和估计的运行时间。在每次进行作业调度时，先计算后备作业队列中每个作业的响应比，从中选出响应比最高的作业投入运行。
    **响应比的变化规律**可描述为：
$$
响应比R_p={\frac{等待时间+要求服务时间}{要求服务时间}}
$$

4. **最短剩余时间**

5. **优先级调度算法**：优先级调度算法又称优先权调度算法，该算法既可以用于作业调度，也可以用于进程调度，该算法中的优先级用于描述作业运行的紧迫程度。
在作业调度中，优先级调度算法每次从后备作业队列中选择优先级最髙的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。在进程调度中，优先级调度算法每次从就绪队列中选择优先级最高的进程，将处理机分配给它，使之投入运行。

根据新的更高优先级进程能否抢占正在执行的进程，可将该**调度算法**分为：
-**非剥夺式优先级调度算法**。当某一个进程正在处理机上运行时，即使有某个更为重要或紧迫的进程进入就绪队列，仍然让正在运行的进程继续运行，直到由于其自身的原因而主动让出处理机时（任务完成或等待事件），才把处理机分配给更为重要或紧迫的进程。
-**剥夺式优先级调度算法**。当一个进程正在处理机上运行时，若有某个更为重要或紧迫的进程进入就绪队列，则立即暂停正在运行的进程，将处理机分配给更重要或紧迫的进程。

而根据进程创建后其优先级是否可以改变，可以将进程优先级分为以下两种：
-**静态优先级**。优先级是在创建进程时确定的，且在进程的整个运行期间保持不变。确定静态优先级的主要依据有进程类型、进程对资源的要求、用户要求。
-**动态优先级**。在进程运行过程中，根据进程情况的变化动态调整优先级。动态调整优先级的主要依据为进程占有CPU时间的长短、就绪进程等待CPU时间的长短。

6. **时间片轮转调度算法**：**时间片轮转调度算法主要适用于分时系统**。在这种算法中，系统将所有就绪进程按到达时间的先后次序排成一个队列，进程调度程序总是选择就绪队列中第一个进程执行，即先来先服务的原则，但仅能运行一个时间片，如100ms。在使用完一个时间片后，即使进程并未完成其运行，它也必须释放出（被剥夺）处理机给下一个就绪的进程，而被剥夺的进程返回到就绪队列的末尾重新排队，等候再次运行。
在时间片轮转调度算法中，时间片的大小对系统性能的影响很大。如果时间片足够大，以至于所有进程都能在一个时间片内执行完毕，则时间片轮转调度算法就退化为先来先服务调度算法。如果时间片很小，那么处理机将在进程间过于频繁切换，使处理机的开销增大，而真正用于运行用户进程的时间将减少。因此时间片的大小应选择适当。
时间片的长短通常由以下因素确定：系统的响应时间、就绪队列中的进程数目和系统的处理能力。
7. **多级反馈队列调度算法**：多级反馈队列调度算法是时间片轮转调度算法和优先级调度算法的综合和发展。通过动态调整进程优先级和时间片大小，多级反馈队列调度算法可以兼顾多方面的系统目标。例如，为提高系统吞吐量和缩短平均周转时间而照顾短进程；为获得较好的I/O设备利用率和缩短响应时间而照顾I/O型进程；同时，也不必事先估计进程的执行时间。
多级反馈队列调度算法

多级反馈队列调度算法的实现思想如下：
1、 应设置多个就绪队列，并为各个队列赋予不同的优先级，第1级队列的优先级最高，第2级队列次之，其余队列的优先级逐次降低。

2、赋予各个队列中进程执行时间片的大小也各不相同，在优先级越高的队列中，每个进程的运行时间片就越小。例如，第2级队列的时间片要比第1级队列的时间片长一倍，……第i+1级队列的时间片要比第i级队列的时间片长一倍。

3、当一个新进程进入内存后，首先将它放入第1级队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第2级队列的末尾，再同样地按FCFS原则等待调度执行；如果它在第2级队列中运行一个时间片后仍未完成，再以同样的方法放入第3级队列……如此下去，当一个长进程从第1级队列依次降到第n 级队列后，在第n 级队列中便釆用时间片轮转的方式运行。

4、仅当第1级队列为空时，调度程序才调度第2级队列中的进程运行；仅当第1~(i-1)级队列均为空时，才会调度第i级队列中的进程运行。如果处理机正在执行第i级队列中的某进程时，又有新进程进入优先级较高的队列（第1 ~(i-1)中的任何一个队列），则此时新进程将抢占正在运行进程的处理机，即由调度程序把正在运行的进程放回到第i级队列的末尾，把处理机分配给新到的更高优先级的进程。

多级反馈队列的优势有：
-终端型作业用户：短作业优先。
-短批处理作业用户：周转时间较短。
-长批处理作业用户：经过前面几个队列得到部分执行，不会长期得不到处理。
