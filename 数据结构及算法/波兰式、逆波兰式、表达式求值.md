# 波兰式、逆波兰式、表达式求值

## 中缀表达式

我们在数学中学到的表达式被称为中缀表达式，操作符号在操作数中间，比如2 + 3 * (5 - 1)。对人类而言，这种表达方式显而易见，求值也很直接，先算乘除再算加减，先算括号内再算括号外。然而，这个表达式对于计算机而言却很费解。

## 前缀表达式

早在1920年，波兰科学家[扬·武卡谢维奇](http://en.wikipedia.org/wiki/Jan_Łukasiewicz)就发明了一种**不需要括号**的表示法，可以用来表示一个计算表达式。即将操作符号写在操作数之前，也就是前缀表达式，即波兰式（Polish Notation，PN）。

比如2 + 3 * (5 - 1)这个表达式的前缀表达式为+ 2 * 3 - 5 1，阅读这个表达式需要从左至右读入表达式，如果一个操作符后面跟着两个操作数时，则计算，然后将结果作为操作数替换这个操作符和两个操作数，重复此步骤，直至所有操作符处理完毕。

可以看出，这种计算过程也相当复杂，需要多次遍历表达式，而且需要识别一个操作符后面跟着两个操作数这种模式，相比而言，下文中的逆波兰式要更为直接和简单。

### 前缀表达式的计算机求值：

从右至左扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算，并将结果入栈，重复上述步骤直到表达式最左端，最后运算得出的值即为表达式的结果。

### 将中缀表达式转换为前缀表达式：

遵循以下步骤：

1. 初始化两个栈：运算符栈s1和存储中间结果的栈s2；
2. 从右至左扫描中缀表达式；
3. 遇到操作数时，将其压入s2；
4. 遇到运算符时，比较其与s1栈顶运算符的优先级；
4.1 如果s1为空，或栈顶运算符为右括号“）”，则直接将此运算符入栈；
4.2 否则，若优先级比栈顶运算符的较高或相等，也将运算符压入s1；
4.3 否则，将s1栈顶的运算符弹出并压入到s2中，再次转到4.1与s1中新的栈顶运算符相比较；
5. 遇到括号时：
5.1 如果是右括号“）”，则直接压入s1；
5.2 如果是左括号“（”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到右括号为止，此时将这一对括号丢弃；
6. 重复步骤2至5，直到表达式的最左端；
7. 将s1中剩余的运算符依次依次弹出并压入s2；
8. 依次弹出s2中的元素并输出，结果即为中缀表达式对应的前缀表达式。

例如，将中缀表达式$ 1+(2+3)*4-5 $转换为前缀表达式的过程如下：

| 扫描到的元素 | S2(栈底->栈顶)    | S1 (栈底->栈顶) | 说明                             |
| ------------ | ----------------- | --------------- | -------------------------------- |
| 5            | 5                 | 空              | 数字，直接入栈                   |
| -            | 5                 | -               | S1为空，运算符直接入栈           |
| )            | 5                 | - )             | 右括号直接入栈                   |
| 4            | 5 4               | - )             | 数字直接入栈                     |
| ×            | 5 4               | - ) ×           | S1栈顶是右括号，直接入栈         |
| )            | 5 4               | - ) × )         | 右括号直接入栈                   |
| 3            | 5 4 3             | - ) × )         | 数字                             |
| +            | 5 4 3             | - ) × ) +       | S1栈顶是右括号，直接入栈         |
| 2            | 5 4 3 2           | - ) × ) +       | 数字                             |
| (            | 5 4 3 2 +         | - ) ×           | 左括号，弹出运算符直至遇到右括号 |
| (            | 5 4 3 2 + ×       | -               | 同上                             |
| +            | 5 4 3 2 + ×       | - +             | 优先级与-相同，入栈              |
| 1            | 5 4 3 2 + × 1     | - +             | 数字                             |
| 到达最左端   | 5 4 3 2 + × 1 + - | 空              | S1中剩余的运算符                 |

因此结果为“$ - + 1 * + 2 3 4 5 $“。

## 后缀表达式

后缀表达式也称为**逆波兰式**（Reverse Polish Notation，RPN），和前缀表达式刚好相反，是将操作符号放置于操作数之后，比如2 + 3 * (5 - 1)用逆波兰式来表示则是：2 3 5 1 - * +。

逆波兰式的计算也是从左往右依次读取，当读到操作符时，将之前的两个操作数做计算，然后替换这两个操作数和操作符，接着读取，重复此步骤。

上面这个步骤可以很容易的用栈来实现：

> 从左往右依次读取表达式，如果是数字则将该数字压栈，如果是符号，则将之前的两个数字出栈，做计算后，将计算结果压栈，直到表达式读取结束。栈中剩下的一个数就是计算结果。

逆波兰式看起来像波兰式反过来，比如`5 + 1`的波兰式是`+ 5 1`，逆波兰式为`5 1 +`或者`1 5 +`。也很明显，逆波兰式并不是简单的将波兰式反过来，因为，减法和除法中减数和被减数、除数与被除数是不能交换的，即`- 10 5`和`- 5 10`就完全不一样。

### 后缀表达式的计算机求值：

与前缀表达式类似，只是顺序是从左至右：

从左至右扫描表达式，遇到数字时，将数字压入堆栈，遇到运算符时，弹出栈顶的两个数，用运算符对它们做相应的计算（次顶元素 op 栈顶元素），并将结果入栈；重复上述过程直到表达式最右端，最后运算得出的值即为表达式的结果。

### 将中缀表达式转换为后缀表达式：

与转换为前缀表达式相似，遵循以下步骤：

1. 初始化两个栈：运算符栈s1和储存中间结果的栈s2；
2. 从左至右扫描中缀表达式；
3. 遇到操作数时，将其压入s2；
4. 遇到运算符时，比较其与s1栈顶运算符的优先级：
4.1 如果s1为空，或栈顶运算符为左括号“(”，则直接将此运算符入栈；
4.2 否则，若优先级比栈顶运算符的高，也将运算符压入s1（注意转换为前缀表达式时是优先级较高或相同，而这里则不包括相同的情况）；
4.3 否则，将s1栈顶的运算符弹出并压入到s2中，再次转到4.1与s1中新的栈顶运算符相比较；
5. 遇到括号时：
5.1 如果是左括号“(”，则直接压入s1；
5.2 如果是右括号“)”，则依次弹出s1栈顶的运算符，并压入s2，直到遇到左括号为止，此时将这一对括号丢弃；
6. 重复步骤2至5，直到表达式的最右边；
7. 将s1中剩余的运算符依次弹出并压入s2；
8. 依次弹出s2中的元素并输出，结果的逆序即为中缀表达式对应的后缀表达式（转换为前缀表达式时不用逆序）。

例如，将中缀表达式$ 1+(2+3)*4-5 $转换为前缀表达式的过程如下：

| 扫描到的元素 | S2(栈底->栈顶)    | S1 (栈底->栈顶) | 说明                               |
| ------------ | ----------------- | --------------- | ---------------------------------- |
| 1            | 1                 | 空              | 数字，直接入栈                     |
| +            | 1                 | +               | S1为空，运算符直接入栈             |
| (            | 1                 | + (             | 左括号，直接入栈                   |
| (            | 1                 | + ( (           | 同上                               |
| 2            | 1 2               | + ( (           | 数字                               |
| +            | 1 2               | + ( ( +         | S1栈顶为左括号，运算符直接入栈     |
| 3            | 1 2 3             | + ( ( +         | 数字                               |
| )            | 1 2 3 +           | + (             | 右括号，弹出运算符直至遇到左括号   |
| ×            | 1 2 3 +           | + ( ×           | S1栈顶为左括号，运算符直接入栈     |
| 4            | 1 2 3 + 4         | + ( ×           | 数字                               |
| )            | 1 2 3 + 4 ×       | +               | 右括号，弹出运算符直至遇到左括号   |
| -            | 1 2 3 + 4 × +     | -               | -与+优先级相同，因此弹出+，再压入- |
| 5            | 1 2 3 + 4 × + 5   | -               | 数字                               |
| 到达最右端   | 1 2 3 + 4 × + 5 - | 空              | S1中剩余的运算符                   |

因此结果为“1 2 3 + 4 × + 5 -”（注意需要逆序输出）。